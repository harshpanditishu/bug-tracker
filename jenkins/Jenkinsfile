pipeline{
    agent any

    stages {
        stage('UNIT TESTS BACKEND') {
            agent{
                docker {
                    image 'snakee/golang-junit:1.21'
                    reuseNode true
                    args '-e GOCACHE=/tmp/go-cache -e GOPATH=/tmp/go'
                    // The args above set the Go build cache and GOPATH to temporary directories to avoid permission issues.
                }
            }
            steps {
                dir('bugtracker-backend') {
                    sh '''
                        set -e
                        go test -v ./... 2>&1 | tee test-output.log
                        go test -v ./... -json | tee test-results.json
                        go-junit-report -in test-output.log -out test-results.xml || true
                    '''
                    // Generate HTML test report from test output
                    sh '''
                        mkdir -p test-reports
                        cat > test-reports/test-report.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Backend Test Results</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        h1 { color: #333; }
        pre { background: #f8f8f8; padding: 15px; border-radius: 4px; overflow-x: auto; }
        .success { color: #28a745; }
        .error { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Backend Go Test Results</h1>
        <pre>
EOF
                        cat test-output.log >> test-reports/test-report.html
                        cat >> test-reports/test-report.html << 'EOF'
        </pre>
    </div>
</body>
</html>
EOF
                    '''
                    // Generate code coverage report in html format and save it to in a different directory
                    sh '''
                        mkdir -p coverage-reports
                    ''' 
                    sh '''
                        go test -coverprofile=coverage.out ./...
                        go tool cover -html=coverage.out -o coverage-reports/coverage.html
                        
                    '''
 
                }
            }
            post {
                always {
                    dir('bugtracker-backend') {
                        // Publish JUnit test results (aggregated with frontend)
                        junit allowEmptyResults: true, testResults: 'test-results.xml'
                        
                        // Publish separate HTML test report for backend
                        publishHTML(target: [
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'test-reports',
                            reportFiles: 'test-report.html',
                            reportName: 'Backend Test Results'
                        ])
                    }
                    // Publish backend code coverage report
                    publishHTML(target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'bugtracker-backend/coverage-reports',
                        reportFiles: 'coverage.html',
                        reportName: 'Backend Code Coverage'
                    ])
                }
            }
        }
        stage('LAUNCH APPLICATION') {
            agent{
                docker {
                    image 'docker:27.5.1'
                    reuseNode true
                    //explain  the args code below?
                   // The args '-v /var/run/docker.sock:/var/run/docker.sock -u root' mount the host's Docker socket into the container,
                   // allowing the container to communicate with the host's Docker daemon. This enables the container to build and run Docker containers as if it were running directly on the host machine.
                   // The '-u root' part runs the container with root user privileges, which may be necessary for certain Docker operations that require elevated permissions.
                    args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
                }
            }
            steps {
                sh 'docker compose up --build -d'
            }
        }
        stage('RUN PLAYWRIGHT API TESTS')
        {
            agent{
                docker {
                    image 'mcr.microsoft.com/playwright:v1.37.1-focal'
                    reuseNode true
                    args '--network="host"'
                }
            }
            steps{
                dir('tests-api') {
                    sh 'npx wait-port http://localhost:8080/api/health --timeout=60000'
                    sh 'npm install'
                    // Run Playwright tests against the running application
                    sh 'npx playwright test --reporter=junit --output=test-results.xml'
                }
            }
        }
        
        stage('UNIT TESTS FRONTEND') {
            agent{
                docker {
                    image 'node:20-alpine'
                    reuseNode true
                }
            }
            steps {
                dir('bugtracker-frontend') {
                    sh 'npm install'
                    //what does --watchAll=false do?
                    //It runs the tests once and then exits, rather than watching for file changes.
                    //This is useful in CI environments where you want the tests to run and finish without waiting for further input.
                    
                    sh 'npm test -- --watchAll=false'
                    // Generate code coverage report in html format
                    sh 'npm run test -- --coverage --coverageReporters=html'
                }
            }
            post {
                always {
                    dir('bugtracker-frontend') {
                        // Publish JUnit test results (aggregated with backend)
                        junit allowEmptyResults: true, testResults: 'test-results.xml'
                        
                        // Publish separate HTML test report for frontend
                        publishHTML(target: [
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: '.',
                            reportFiles: 'test-report.html',
                            reportName: 'Frontend Test Results'
                        ])
                        
                        // Publish frontend code coverage report
                        publishHTML(target: [
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'coverage',
                            reportFiles: 'index.html',
                            reportName: 'Frontend Code Coverage'
                        ])
                    }
                }
            }
        }
        
    }
    
    post {
        always {
            echo 'END OF PIPELINE'
        }
    }
}